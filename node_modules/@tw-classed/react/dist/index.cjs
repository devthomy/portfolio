Object.defineProperty(exports, '__esModule', { value: true });

var jsxRuntime = require('react/jsx-runtime');
var core = require('@tw-classed/core');
var react = require('react');

const COMPONENT_SYMBOL = Symbol.for("tw-classed.component");
const isClassedComponent = (value)=>{
    return (typeof value === "object" || typeof value === "function") && Reflect.has(value, COMPONENT_SYMBOL);
};

const cx = (...args)=>args.filter(Boolean).join(" ");
const internalClassed = (elementType, classNames, { merger =cx  } = {})=>{
    const toParse = Array.from(classNames);
    const isClassed = isClassedComponent(elementType);
    if (isClassed) {
        toParse.unshift(elementType);
    }
    const { className , variants , defaultVariants , compoundVariants , dataAttributes  } = core.parseClassNames(toParse);
    const Comp = /*#__PURE__*/ react.forwardRef(({ as , className: cName , ...props }, forwardedRef)=>{
        const Component = isClassed ? elementType : typeof elementType === "object" ? elementType : as || elementType;
        const dataAttributeProps = core.getDataAttributes({
            props,
            dataAttributes,
            variants,
            defaultVariants
        });
        // Map props variant to className
        const variantClassNames = react.useMemo(()=>{
            return core.mapPropsToVariantClass({
                variants,
                defaultVariants,
                compoundVariants
            }, props, true);
        }, [
            props
        ]);
        const merged = react.useMemo(()=>merger(className, variantClassNames, cName), [
            className,
            cName,
            variantClassNames
        ]);
        return /*#__PURE__*/ jsxRuntime.jsx(Component, {
            className: merged,
            ...props,
            ...isClassed && Object.keys(defaultVariants).length ? defaultVariants : {},
            ...dataAttributeProps,
            as: isClassed ? as : undefined,
            ref: forwardedRef
        });
    }); // Add variant types
    Comp.displayName = typeof elementType !== "string" ? elementType.displayName || elementType.name || "Compoonent" : `TwComponent(${elementType})`;
    // Set variables to check if component is classed
    Reflect.set(Comp, core.TW_VARS, {
        className,
        variants,
        defaultVariants,
        compoundVariants
    });
    Reflect.set(Comp, COMPONENT_SYMBOL, true);
    return Comp;
};
const createClassed = (config)=>{
    const classedWithConfig = (elementType, ...args)=>{
        return internalClassed(elementType, args, config);
    };
    const classedProxy = new Proxy(classedWithConfig, {
        get: (_, type)=>{
            return function(...args) {
                return classedWithConfig.apply(this, [
                    type,
                    ...args
                ]);
            };
        }
    });
    return {
        classed: classedProxy
    };
};
const makeStrict = (component)=>component;

const classedProxy = createClassed().classed;

const DERIVED_COMPONENT_SYMBOL = Symbol.for("tw.derivedComponent");
// export interface DeriveClassedFunction1 {
//   <
//     Type extends ClassedComponentType<any>,
//     Props extends {} = Omit<React.ComponentProps<Type>, "as" | "ref">,
//     HTMLType = null,
//     InferredType = HTMLType extends null ? 0 : 1
//   >(
//     callback: React.ForwardRefRenderFunction<
//       HTMLType extends null ? React.ComponentRef<Type> : HTMLType,
//       Props
//     >
//   ): HTMLType extends null
//     ? DerivedComponentType<Type, Props>
//     : DerivedComponentType<
//         React.ComponentType<any>,
//         Props & React.HTMLProps<HTMLType>,
//         Type[$$ClassedVariants]
//       >;
// }
const deriveClassed = (fn)=>{
    const derived = /*#__PURE__*/ react.forwardRef((props, ref)=>{
        return fn(props, ref);
    });
    /**
   * This is a derived component, so we need to set the symbol to signal internals to pass down `as` prop.
   */ Reflect.set(derived, DERIVED_COMPONENT_SYMBOL, true);
    Reflect.set(derived, COMPONENT_SYMBOL, true);
    derived.displayName = `Tw.DerivedComponent`;
    return derived;
};

exports.classed = classedProxy;
exports.createClassed = createClassed;
exports.deriveClassed = deriveClassed;
exports.makeStrict = makeStrict;
